es#+TITLE: Operate Resources in Public and Private Clouds
#+TITLE: Thanks to OpenStack
#+AUTHOR: Ronan-Alexandre Cherrueau, Adrien Lebre, Marie Delavergne, Didier Iscovery
#+EMAIL: {firstname.lastname}@inria.fr
#+DATE: [2021-11-11 jeu.]

#  ___________________________________________________________________________
# / Green's Law of Debate:                                                    \
# \         Anything is possible if you don't know what you're talking about. /
#  ---------------------------------------------------------------------------
#         \   ^__^
#          \  (oo)\_______
#             (__)\       )\/\
#                 ||----w |
#                 ||     ||

# Do ~C-c C-c~ in the following to export and publish the Lab after
# reviewing the [[lst:export]] and [[lst:publish]] scripts.
#+BEGIN_SRC elisp :results silent :noweb yes :exports none
<<lst:export>>
<<lst:publish>>
#+END_SRC

#+BEGIN_abstract
OpenStack has become the de-facto solution to operate compute, network
and storage resources in public and private clouds. In this lab, we
are going to:
- Deploy an all-in-one OpenStack with [[https://opendev.org/x/microstack/][Snap microstack]].
- Operate this OpenStack to manage IaaS resources (e.g., boot VMs,
  setup a private Network).
- Deploys a Wordpress as a Service.
- Automatize all the stuff with the Heat template engine (i.e., manage
  your cloud from your sofa!).

Find the slides of the lecture [[cdn-url:2018-2019/os-polytech/docs/CloudFogEdgeIntro.pdf][here]] and [[cdn-url:2018-2019/os-polytech/docs/openstack-slides.pdf][there]].  Find the collaborative
editor to follow lab completion [[https://notes.inria.fr/L5mGTNGORdewfkfINm81kA][here]].
# This document is an [[https://orgmode.org/][Org mode]] document.
#+END_abstract

#+TOC: headlines 3

* Lecture Notes for the Teacher                                    :noexport:
** Export
Do ~C-c C-c~ in the following
#+NAME: lst:export
#+BEGIN_SRC elisp :results silent :noweb yes
  (let* ((output-dir "output-solution")
	 (outfile.txt (org-export-output-file-name ".txt" nil output-dir))
	 (outfile.html (org-export-output-file-name ".html" nil output-dir)))

    (face-spec-set 'yaml-tab-face '((t (:foreground unspecified :background unspecified))))
    ;; Clean everything
    (delete-directory output-dir t)

    ;; Export subject and source code
    (make-directory output-dir)
    (org-export-to-file 'ascii outfile.txt)
    (org-export-to-file 'html outfile.html)
    (org-babel-tangle)

    ;; Make the tp.tar.gz
    (shell-command (format "tar czf tp.tar.gz --exclude=index-solution.html --transform 's|^%s|lab-os|' %s"
			   output-dir output-dir)))
#+END_SRC

** Publish
Do ~C-c C-c~ in the following.

Put it on my personal website.
#+NAME: lst:publish
#+BEGIN_SRC elisp :results silent :noweb yes
  (let* ((base-dir "~/Documents/site/teachings/2021-2022/")
	 (export-dir (concat base-dir "os-imt/")))

    ;; ;; Delete export if it exists. Always start from the ground base.
    ;; (when (file-directory-p export-dir)
    ;;   (delete-directory export-dir t))

    ;; Create directory and copy index files
    ;; (make-directory export-dir)
    (shell-command (format "cp -r output/index-solution.html %s" export-dir)))
#+END_SRC

** Hide/show solutions
Do ~C-c C-c~ in one of the followings.

Hide solutions
#+BEGIN_SRC elisp :results silent :noweb yes
(save-excursion
  ;; Change "#+BEGIN_solution" into "#+BEGIN_comment solution"
  (while (re-search-forward "\\(BEGIN\\|END\\)_solution" nil t)
    (replace-match "\\1_comment\n# solution" 'fixed-case))

  ;; Change "* heading :solution" into "* COMMENT heading :solution:"
  (org-map-entries (lambda () (when (not (org-in-commented-heading-p t))
                                (org-toggle-comment)))
                   "+solution" 'file)
  (save-buffer))
#+END_SRC

Show solutions
#+BEGIN_SRC elisp :results silent :noweb yes
(save-excursion
  ;; Change "#+BEGIN_comment solution" into "#+BEGIN_comment"
  (while (re-search-forward "\\(BEGIN\\|END\\)_comment\n# solution" nil t)
    (replace-match "\\1_solution" 'fixed-case))

  ;; Change "* COMMENT heading :solution" into "* heading :solution:"
  (org-map-entries (lambda () (when (org-in-commented-heading-p)
                                (org-toggle-comment)))
                   "+solution" 'file)
  (save-buffer))
#+END_SRC

** Troubleshooting
- ~chmod~ doesn't work on WSL. Put your key in the filesystem managed
  by linux, i.e., ~/home/user~.
- Starting a VM doesn't work with an error that neutron cannot bind
  port: if this is a Vagrant box with libvirt, then ensure that the
  box is built with virtio.  This is not the case of the
  'generic/ubuntu2004'.
- Attention que des services ne soient pas installés:
  + mysql: bloque l'installation de microstack
  + memcachd: Retourne une erreur de cache dans Horizon
  + `File Access Denied` ou `ssh: Permission denied` il faut réinstaller le openstackclient.
    : sudo snap remove --purge openstackclients
    : sudo snap install openstackclients --classic

* Requirements and Setup
:PROPERTIES:
:CUSTOM_ID: sec:req
:END:
** Environment
OpenStack needs, at least, 6 Go of RAM to run. And plenty more to
start VMs on it. Therefore, this lab relies on [[https://www.grid5000.fr/][Grid'5000]], a testbed
for experimental research, to acquire a /Lab machine/ larger than your
personal one. The Lab machine is a Ubuntu20.04 with 128Go of RAM and
32 CPU cores. This should be enough resources for this lab!

The lab makes use of [[https://github.com/CanonicalLtd/microstack][Snap microstack]]: OpenStack in a Snap that you can
run locally on a single machine. Snap is the Canonical's App delivery
mechanism. It enables developers to bundle all dependencies into a
single app package. And so does Snap microstack for an all-in-one
OpenStack on your machine.

An all-in-one OpenStack means that your machine will contain both
services to /operate/ and /host/ virtualized resources. For instance,
the ~nova-conductor~ to operate the boot of a VM, and ~nova-compute~
to host the VM. This is a good setup for a lab, but not for
production. There are several other options such as [[https://docs.openstack.org/devstack/latest/index.html][DevStack]],
[[https://docs.openstack.org/puppet-openstack-guide/latest/][Puppet-OpenStack]] or [[https://docs.openstack.org/developer/kolla-ansible/][Kolla-ansible]] and all matters. But, Snap
microstack takes only 2 minutes to deploy OpenStack (instead of 30
minutes for other options).

#+BEGIN_note
- Devstack is good for OpenStack developers.
- Puppet-OpenStack or Kolla-ansible are good for production
  deployments.
#+END_note

** Access the Lab machine
:PROPERTIES:
:CUSTOM_ID: sec:assign-lab
:END:
Find the assignation list of Lab machine per student on the
collaborative editor
https://notes.inria.fr/L5mGTNGORdewfkfINm81kA.



First thing first, you have to connect to the Lab machine.
Unfortunately, the Lab machine isn't available publicly, but hides
behind the Grid'5000 private network. One solution, as explained in
the [[https://www.grid5000.fr/mediawiki/index.php/Getting_Started#Connecting_for_the_first_time][official tutorial]], consists in opening an SSH connection to the
publicly available ~access.grid5000.fr~ machine, and from there, doing
a second SSH connection to the Lab machine. But this solution is
fairly limited since it doesn't give an access to services from your
own machine[fn:g5k-tunnel].

To ease the interaction between your own machine and the Lab one, you
should setup the Grid'5000 [[https://en.wikipedia.org/wiki/Virtual_private_network][VPN]]. The Grid'5000 VPN gives you access to
the Grid'5000 private network and thus, Lab machines wherever your are
on the globe.

Next gives you the procedure on Ubuntu, but should be similar on other
UNIX systems. You can also do it on Windows, however expect to be on
your own in case of troubles.

1. Install the [[https://openvpn.net/][OpenVPN]] client
   : sudo apt update -y && sudo apt install -y openvpn
3. Go on [[https://api.grid5000.fr/stable/users/][UMS]] > "My Account" tab > "VPN certificates" item.
4. "Create new certificate" > "Create with passphrase", and fill the
   form with a new password (remember it!).
5. Click on "Zip file" Action > store it somewhere on your personal
   machine > unzip it. If the ~unzip~ program is unavailable, install
   it with ~sudo apt install unzip~.
   : unzip <g5k_login>_vpnclient.zip -d g5k_vpnclient
6. Run OpenVPN client with sudo
   : cd g5k_vpnclient; sudo openvpn Grid5000_VPN.ovpn
7. Fill in the password of Step 3 to the question ~Enter Private Key
   Password:~.

You correctly setup the VPN and can access Grid'5000 private network
if your *shell hangs* and you see the following route in your routing
table.
#+begin_src bash
$ ip route

# ...
10.0.0.0/8 via 172.20.255.254 dev tun0
172.16.0.0/16 via 172.20.255.254 dev tun0
172.20.0.0/16 via 172.20.255.254 dev tun0
172.20.192.0/18 dev tun0 proto kernel scope link src 172.20.192.5
# ...
#+end_src

You can finally connect to your Lab machine in another shell with the
following SSH command. Use ~lab-os~ as password.
: ssh -l root <ip-of-your-lab-machine>

The rest of this lab *proceeds on the Lab machine*.

Don't forget to use tmux! (see the pad)

** Resources of the Lab
:PROPERTIES:
:CUSTOM_ID: sec:rscs-lab
:END:
Get the resources of the lab at [[https://raw.githubusercontent.com/Marie-Donnie/lectures/master/2021-2022/os-imt/tp.tar.gz]]:

#+BEGIN_SRC bash
curl https://raw.githubusercontent.com/Marie-Donnie/lectures/master/2021-2022/os-imt/tp.tar.gz -o tp.tar.gz -L
tar xzf tp.tar.gz
cd lab-os
#+END_SRC

The archive contains:
- setup.sh :: Script that sets up the lab.
- teardown.sh :: Script that uninstalls the lab.
- rsc :: Resource directory with bash scripts useful for the lab.

** Setup OpenStack
Install snap.
: sudo apt update
: sudo apt install snapd

# Ensure OpenStack microstack is not already installed and remove it otherwise.
# : snap info microstack | fgrep -q installed && sudo snap remove --purge microstack

Install the latest version of OpenStack from the snap store.
: sudo snap install microstack --beta --devmode

Execute the ~setup.sh~ file with sudo to initialize OpenStack (setup
networks, flavors, images, ...).
: sudo ./setup.sh

#+BEGIN_do
Then, ensure OpenStack services are running on your machine. Find the
snap command that lists microstack OpenStack services and the
status? What is the purpose of each service?

#+BEGIN_solution
: snap services microstack|sort

- glance-* :: Glance to manage VM images: ~openstack image --help~.
- horizon-* :: OpenStack Web dashboard: [[https://<ip-of-your-lab-machine>]].
- keystone-* :: Keystone to manage authentication and authorization
                on OpenStack.
- neutron-* :: Neutron to manage networks: ~openstack network --help~.
- nova-* :: Nova to manage VM: ~openstack server --help~.
- memcached :: Cache used by all OpenStack services
- mysqld :: Database used by all OpenStack services
- rabbitmq-server :: Communication bus used by all OpenStack services
#+END_solution
#+END_do

*** Setup script                                                   :noexport:
#+BEGIN_SRC bash :noweb tangle :tangle output/setup.sh :shebang #!/usr/bin/env bash
set -o errexit
set -o xtrace

# Install the bare necessities
apt install --yes --quiet silversearcher-ag curl tcpdump kmod vim htop lynx crudini
# On ubuntu 20.04 only
apt install --yes --quiet bat

# Set the admin password to keystone
snap set microstack config.credentials.keystone-password=lab-os
snap set microstack config.host.check-qemu=True

# Initialize  OpenStack
microstack.init --auto --control

<<lst:undo-kvm>>

# Install openstack client
snap info openstackclients | fgrep -q installed && sudo snap remove --purge openstackclients
snap install --channel=latest/stable openstackclients --classic

# Put snap openstackclients into the path.
export PATH=/snap/bin:$PATH

set +o xtrace

# Remove icmp and tcp security group rules of `microstack.init --auto`
for rule in $(microstack.openstack security group rule list --protocol icmp -c ID -f value)
do
    microstack.openstack security group rule delete "${rule}"
done
for rule in $(microstack.openstack security group rule list --protocol tcp -c ID -f value)
do
    microstack.openstack security group rule delete "${rule}"
done

<<lst:undo-extnet-setup>>
set -o xtrace
#+END_SRC

*** Teardown script                                                :noexport:
#+BEGIN_SRC bash :noweb tangle :tangle output/teardown.sh :shebang #!/usr/bin/env bash
set -o xtrace

<<lst:undo-extnet-setup>>
<<lst:remove-heat>>

sudo snap remove --purge openstackclients
sudo snap remove --purge microstack
#+END_SRC

* Play with OpenStack (as an Admin)
:PROPERTIES:
:CUSTOM_ID: sec:play-with-os
:END:
** OpenStack Horizon dashboard
One service deployed is the OpenStack dashboard (Horizon). On your own
machine, horizon is reachable from the web browser at
[[https://<ip-of-your-lab-machine>]] with the following credentials:
- login: ~admin~
- password: ~lab-os~

From here, you can reach ~Project > Compute > Instances > Launch
Instance~ and boot a virtual machine given the following information:
- a name (e.g., ~horizon-vm~)
- an image (e.g., ~cirros~) and set the ~Create New Volume~ to "No"
- a flavor to limit the resources of your instance (we recommend
  ~m1.tiny~)
- and a network setting (must be ~test~)

You should select options by clicking on the big arrow on the right of
each possibility. When the configuration is OK, the ~Launch Instance~
button should be enabled. After clicking on it, you should see the
instance in the ~Active~ state in less than a minute.

Now, you have several options to connect to your freshly deployed VM.
For instance, after clicking on its name, Horizon provides a virtual
console under the ~Console~ tab. So, you can use the following
credentials to access the VM:
- login: ~cirros~
- password: ~gocubsgo~

However, as a /real DevOps/, you will prefer to access to your VM by
the command line interface \dots

** Unleash the operator in you
:PROPERTIES:
:CUSTOM_ID: sec:os-cli
:END:
While Horizon is helpful to discover OpenStack features, this is not
the tool of choice for an operator.  An operator prefers command line
interface 😄.  You are lucky, OpenStack provides one.

All operations to manage OpenStack are done through one unique command
line, called ~openstack <service> <action> ...~.  Doing an ~openstack
--help~ displays the /really long/ list of services/possibilities
provided by this command.  The following gives you a selection of the
most often used commands to operate your Cloud:
- List OpenStack running services :: ~openstack endpoint list~
- List images :: ~openstack image list~
- List flavors :: ~openstack flavor list~
- List networks :: ~openstack network list~
- List computes :: ~openstack hypervisor list~
- List VMs (running or not) :: ~openstack server list~
- Get details on a specific VM :: ~openstack server show <vm-name>~
- Start a new VM :: ~openstack server create --image <image-name> --flavor <flavor-name> --network <network-name> <vm-name>~
- View VMs logs :: ~openstack console log show <vm-name>~

#+BEGIN_do
Try one of these commands.  Does it works?  What is the problem, how
to fix it?  Hint: Look at the [[os-doc:python-openstackclient,cli/authentication.html][password authentication process]] for the
CLI. Second hint: After you saw how cumbersome it is to add the
credentials to each command, you can find how to source them thanks to
the dashboard (see [[https://docs.openstack.org/liberty/install-guide-obs/keystone-openrc.html]]).

#+BEGIN_solution
#+BEGIN_SRC bash
$ openstack endpoint list
Missing value auth-url required for auth plugin password
#+END_SRC

Similarly to Horizon, you have to provide your credentials to the
OpenStack CLI and tell it the URL of the authentication service.
There are *two options* to achieve this.  First, to give them as
arguments of the command.

#+BEGIN_SRC bash
openstack server list --os-auth-url=https://<ip-of-your-lab-machine>:5000/v3/ \
                        --os-username=admin \
                        --os-password=lab-os \
                        --os-project-name=admin \
                        --os-user-domain-name=Default \
                        --os-project-domain-id=default
#+END_SRC

This is a bit cumbersome since you have to give them every time.  The
second option consists in seting your credentials as variables in your
bash [[https://www.gnu.org/software/coreutils/manual/html_node/env-invocation.html#env-invocation][environment]].  Hence, the CLI automatically reads these variables
instead.  You can find a pre-generated file with all variables
properly set under the Horizon interface by clicking on the ~admin~
dropdown list at the top right corner, and get the "OpenStack RC
File".

To setup your environment, download this file on your Lab machine and
source it.
: source ./admin-openrc.sh

You can then check that your environment is correctly set.
#+BEGIN_SRC bash
$ env|fgrep OS_|sort

OS_AUTH_URL=http://<ip-of-your-lab-machine>:5000/v3/
OS_IDENTITY_API_VERSION=3
OS_INTERFACE=public
OS_PASSWORD=lab-os
OS_PROJECT_DOMAIN_ID=default
OS_PROJECT_ID=2bad71b9246a4a06a0c9daf2d8896108
OS_PROJECT_NAME=admin
OS_REGION_NAME=microstack
OS_USER_DOMAIN_NAME=Default
OS_USERNAME=admin
#+END_SRC
#+END_solution
#+END_do

#+BEGIN_do
Using all these commands, use the CLI to start a new tiny cirros VM
called ~cli-vm~.
#+BEGIN_solution
#+BEGIN_src bash
openstack server create \
  --image cirros \
  --flavor m1.tiny \
  --network test \
  cli-vm
#+END_src
#+END_solution
#+END_do

Then, display the information about your VM with the following
command:
: openstack server show cli-vm

Note in particular the ~status~ of your VM.
: openstack server show cli-vm -c status -f json

This status will go from ~BUILD~: OpenStack is looking for the best
place to boot the VM; to ~ACTIVE~: your VM is running.  The status
could also be ~ERROR~ if you are experiencing hard times with your
infrastructure.

#+BEGIN_do
What is the purpose of the ~-c~ and ~-f~ argument in the previous
command.
#+BEGIN_solution
#+BEGIN_example
$ openstack server create --help | fgrep -A 6 "output formatters:"
output formatters:
  output formatter options

  -f {json,shell,table,value,yaml}, --format {json,shell,table,value,yaml}
                        the output format, defaults to table
  -c COLUMN, --column COLUMN
                        specify the column(s) to include, can be repeated
#+END_example
#+END_solution
#+END_do

A VM in ~ACTIVE~ state still has to go through the [[http://www.tldp.org/LDP/intro-linux/html/sect_04_02.html][boot process and
init]]. Hence, you may still have to wait for one minute or two that
your VM finishes to boot. You can check that your VM finished to boot
by looking at its logs with ~openstack console log show cli-vm~. A
CirrOS VM finished to boot when last lines are:
#+BEGIN_EXAMPLE
=== cirros: current=0.4.0 latest=0.4.0 uptime=29.16 ===
  ____               ____  ____
 / __/ __ ____ ____ / __ \/ __/
/ /__ / // __// __// /_/ /\ \
\___//_//_/  /_/   \____/___/
   http://cirros-cloud.net


login as 'cirros' user. default password: 'gocubsgo'. use 'sudo' for root.
cli-vm login:
#+END_EXAMPLE

*** Make the world reaches the VM
The [[os-doc:neutron][neutron]] service manage networks in OpenStack.  Neutron
distinguishes, at least two kind of networks.  First, the /project (or
tenant) network/ to provide communication between VMs of the same
project.  Second, the /provider (or external) network/ to provide an
access to the VM from the outside.  With the
previous ~openstack server create~ command, the VM boots with an IP on
the tenant network.  Consequently, you cannot ping your VM from an
external network (e.g., the Lab machine).

#+BEGIN_do
Find the IP address of the ~cli-vm~. Check that you can ping that
address from the ~horizon-vm~ (using the ~Console~ tab in the Horizon
dashboard).  Ensure that you *cannot* ping that VM from the Lab machine.

#+BEGIN_solution
#+BEGIN_SRC bash
PRIV_IP=$(openstack server show cli-vm -c addresses -f value | sed -E 's/test=(.+)/\1/g')
echo "Private IP of cli-vm is ${PRIV_IP}"
ping -c 3 "${PRIV_IP}" # From horizon-vm: 0% packet loss, From lab: 100% packet loss
#+END_SRC
#+END_solution
#+END_do

To ping your VM from the Lab machine, you have to affect it an IP
address of the ~external~ network.  The management of the external
network is done typically at the level of the infrastructure and not
by OpenStack.  OpenStack allows to access IP addresses of that network
using /floating IPs/.  A floating IP is not allocated to a specific VM
by default. Rather, an operator has to explicitly /pick/ one from a
pool and then attach it to its VM. Thus, if the VM dies for some
reason, the operator does not lose the floating IP -- it remains her
own resource, ready to be attached to another VM.  For instance, OVH
uses that mechanism to assign public IP addresses to VMs.

Affect a floating IP of the ~external~ network to your machine if you
want it to be pingable from the host.
#+BEGIN_SRC bash
ALLOCATED_FIP=$(openstack floating ip create \
  -c floating_ip_address -f value external)
echo "${ALLOCATED_FIP}"
openstack server add floating ip cli-vm "${ALLOCATED_FIP}"
#+END_SRC

Then, ask again for the status of your VM and its IPs.
: openstack server show cli-vm -c status -c addresses

#+BEGIN_do
Ping ~cli-vm~ on its floating IP.
: ping -c 3 "$ALLOCATED_FIP"

Does it work? Why? Hint: OpenStack limits the traffic for security
reasons.  The mechanisms to control the traffic in OpenStack is called
[[os-doc:neutron,feature_classification/general_feature_support_matrix.html#operation_Security_Groups][security group]].  Find the command that list the security group rules
of the ~admin~ project.
# (i.e., ~openstack project show admin~).

#+BEGIN_solution
#+BEGIN_src bash
$ SECGROUP_ID=$(openstack security group list --project admin -f value -c ID)
$ openstack security group rule list --long -c "IP Protocol" -c "IP Range" -c Direction $SECGROUP_ID

+-------------+------------------+-----------+
| IP Protocol | IP Range         | Direction |
+-------------+------------------+-----------+
| None        | 192.168.222.0/24 | ingress   |
| None        | 0.0.0.0/0        | egress    |
+-------------+------------------+-----------+
#+END_src

By default, OpenStack is very conservative and only allows two kinds
of intercommunication patterns:
1. Any intercommunication among hosts of the same project.  This is
   the first line.  It should be read as "/Neutron allows incoming
   traffic (~ingress~) between/ /hosts of ~192.162.222.*~ of any
   protocol (~None~ specific ones)/".
2. Any kind of outgoing communications.  This is the second line.  It
   should be read as "/Neutron allows outgoing traffic (~egress~) to
   anywhere (~0.0.0.0/0~) and of any protocol (~None~)/".
And that's it.  Since there are no more rules, it means that OpenStack
prevents all other ingress communications including communications on
~10.20.20.*~.

#+BEGIN_note
Commonly, OpenStack states the first intercommunication pattern of
"allowing traffic among hosts of the same project" not as we see it
here, but using a /remote security group/.  While specifying a
security group rule, the DevOps gives either an IP Range (e.g.,
~192.168.222.0/24~) with ~--remote-ip~, or machines that belongs to a
specific group with ~--remote-group~.  Using the latter, OpenStack
implements the first intercommunication pattern with a rule that tells
Neutron to allow traffic between hosts of the group ~$SECGROUP_ID~.

#+BEGIN_src bash
$ openstack security group rule create $SECGROUP_ID --remote-group $SECGROUP_ID

# It appears as so in the security group rule list:
+-------------+------------------+-----------+
| IP Protocol | Remote Group     | Direction |
+-------------+------------------+-----------+
| None        | <SECGROUP_ID>    | ingress   |
+-------------+------------------+-----------+
#+END_src
#+END_note
#+END_solution

Then, make it works for ~10.20.20.0/24~ network.  See examples of
security groups rules in the [[https://docs.openstack.org/neutron/latest/admin/deploy-lb-selfservice.html#verify-network-operation][neutron doc]].

#+BEGIN_solution
To make it works, you have to setup new rules in the security group of
the ~admin~ project. The following rules allow ICMP packets (for ping)
and TCP on port 22 (for SSH connection) on the VM.
#+BEGIN_src bash
openstack security group rule create $SECGROUP_ID --proto icmp --remote-ip 10.20.20.0/24
openstack security group rule create $SECGROUP_ID --proto tcp --remote-ip 10.20.20.0/24 \
  --dst-port 22
#+END_src
#+END_solution
#+END_do


Once you succeed to ping the vm, you should also be able to SSH on it.
: ssh -l cirros "$ALLOCATED_FIP"

#+BEGIN_do
Go on, and play with the ~openstack~ CLI.  List all features offered
by Nova with ~openstack server --help~ and figure out how to:
1. SSH on ~cli-vm~ using its name rather than its IP;
2. Pause it, note the footprint on the ram of the hypervisor, and unpause it;
3. +Suspend it, note the footprint on the ram of the hypervisor, and
   resume it;+ Does not work right now 😒.
4. Create a snapshot of ~cli-vm~;
5. Boot a new machine ~cli-vm-clone~ from the snapshot;
6. Delete ~cli-vm-clone~;

#+BEGIN_solution
#+BEGIN_SRC bash
# 1.
openstack server ssh cli-vm -l cirros
# 2.
CLI_VM_HYPERVISOR=$(openstack server show cli-vm -c "OS-EXT-SRV-ATTR:hypervisor_hostname" -f value)
openstack hypervisor show -c free_ram_mb "$CLI_VM_HYPERVISOR"
openstack server pause cli-vm; openstack server show cli-vm -c status
openstack hypervisor show -c free_ram_mb "$CLI_VM_HYPERVISOR"
openstack server unpause cli-vm; openstack server show cli-vm -c status
# 3.
openstack server suspend cli-vm; openstack server show cli-vm -c status
openstack hypervisor show -c free_ram_mb "$CLI_VM_HYPERVISOR"
openstack server resume cli-vm; openstack server show cli-vm -c status
# 4.
openstack server image create --name cli-vm-img cli-vm; openstack image list
# 5.
openstack server create --wait --flavor m1.tiny \
  --network test --image cli-vm-img \
  cli-vm-clone
# 6.
openstack server delete cli-vm-clone
#+END_SRC
#+END_solution
#+END_do

*** Make the VM reaches the world
# *Note for the teacher:* The [[lst:undo-extnet-setup]] code undoes the
# [[https://opendev.org/x/microstack/src/commit/1a25e50a172db7331edf2f836f3c2005222bb4c5/snap-overlay/bin/setup-br-ex#L21-L22][microstack network setup]], so students have to resolve the next
# challenge (i.e., the next ~begin_do~). This bash snippet is tangle
# into [[file:setup.sh]] and could be disable in case of a no
# network-oriented students.  To disable it, simply comment that
# headline.
#+NAME: lst:undo-extnet-setup
#+BEGIN_SRC bash :exports none
# Undo the external network setup of `microstack.init --auto`
sysctl -w net.ipv4.ip_forward=0 > /dev/null
extcidr=10.20.20.0/24  # find it with `sudo iptables -t nat -L`

# Flush the nat table
# iptables -w -t nat -D POSTROUTING -s $extcidr ! -d $extcidr -j MASQUERADE > /dev/null
iptables -Z
iptables -t nat -F
iptables -t nat -X
#+END_SRC

From the cirros, ping the outside world.
: openstack server ssh cli-vm --login cirros
: ping 8.8.8.8  # GOOGLE could you HEAR me?!

#+BEGIN_do
Does it work? Why? To help you in your diagnosis, here is a list of
hints to check:
- Ping the VM and Google *from the Lab machine*. The ping should work
  for both. What does it mean for the Lab machine regarding
  communications between VMs and the Internet?
  #+BEGIN_solution
  : ping -c 2 $ALLOCATED_FIP; ping -c 2 8.8.8.8
  The ping from the Lab machine works for both the VM and Google.
  Thus, the Lab machine /could be a gateway/ between VMs and the
  Internet.
  #+END_solution

- Note the IP address of ~$ALLOCATED_FIP~. From which network this IP
  comes? Which NIC serves that network on the Lab machine?
  #+BEGIN_solution
  : echo "$ALLOCATED_FIP"
  : openstack subnet show external-subnet -c cidr -c allocation_pools
  : ip address | fgrep -B 2 10.20.20
  The IP of the VM comes from the network 10.20.20.0/24, which is
  served on the Lab machine by ~br-ex~.
  #+END_solution

- Do a ~tcpdump~ on that NIC. Do you see the ICMP packets from
  ~$ALLOCATED_FIP~ that flow over that NIC?
  #+BEGIN_solution
  : sudo tcpdump -nni br-ex icmp
  The ~tcpdump~ on ~br-ex~ shows ping ~echo request~ packets, but no
  ~echo reply~. So the packets are lost somewhere... Remember
  the Lab machine should play a role of gateway between VMs and
  the Internet.  Thus, packets should flow through the NIC of the
  default route: let's see what is happening there.
  #+END_solution

- Find the route that forward packets to the Internet on Lab machine.
  Do a ~tcpdump~ on the NIC that servers that route. Do you see the
  ICMP packets flow over that NIC?
  #+BEGIN_solution
  To ensure that something is wrong on the Lab machine regarding its
  role of gateway between VMs and the Internet, let's find the route
  that forwards Google packets out of the Lab machine.
  : $ ip route
  :
  : default via 192.168.121.1 dev eth0 proto dhcp src 192.168.121.77 metric 100
  : 10.20.20.0/24 dev br-ex proto kernel scope link src 10.20.20.1
  : 192.168.121.0/24 dev eth0 proto kernel scope link src 192.168.121.77
  : 192.168.121.1 dev eth0 proto dhcp scope link src 192.168.121.77 metric 100
  The command does not show up an /explicit/ route for ~8.8.8.0/9~
  packets. This means that packets are supposed to flow through the
  /default/ route served by the ~eth0~ NIC on my machine.

  Next, do a ~tcpdump~ on that NIC to see if the ICMP packet go
  through it.
  : sudo tcpdump -nni eth0 icmp
  Nothing appears. So ICMP packet are lost somewhere between ~br-ex~
  and ~eth0~, despite the first hint.

  To put it differently, the Lab machine does not forward the incoming
  traffic on ~br-ex~ to ~eth0~. And this is normal, there is [[https://serverfault.com/questions/749682/ip-forwarding-on-linux-anything-important-to-make-sure-to-do-or-know][no reason]]
  for Linux to enable this by default.  However in our case, we have to
  activate it.  This is called /Kernel IP Forwarding/, and it could be
  set up with the next command (or ~echo 1 >
  /proc/sys/net/ipv4/ip_forward~).
  : sudo sysctl -w net.ipv4.ip_forward=1

  #+BEGIN_note
  Sometimes activating the kernel IP forwarding is not enough,
  [[http://www.microhowto.info/howto/enable_forwarding_of_ipv4_packets.html#idp17360][especially in case of firewalling]]. A common place to perform packet
  filtering of routed traffic is in the ~FORWARD~ chain of the filter
  table.
  : sudo iptables -t filter -L FORWARD -n

  If a rule drops packet, then it is mandatory to accept them with a
  new rule.
  : sudo iptables -A FORWARD -j ACCEPT
  #+END_note
  #+END_solution

- After making the packets flow on the second NIC, is everything OK
  with the IP address of the source in the ~tcpdump~ on ~eth0~?
  #+BEGIN_solution
  From now, the ping of Google from the VM reaches Internet via ~eth0~
  (as seen by ~tcpdump -nni eth0 icmp~). Unfortunately, it still does
  not do the trick, because the packet goes out with the ~10.20.20.*~
  source address. For this reason, Google sees ~ICMP echo request~
  incoming packets from ~10.20.20.*~ and hence, replies ~ICMP echo
  reply~ to ~10.20.20.*~ which does not makes sense out of a private
  network.

  You have to change the source IP of out packet (~10.20.20.*~) to
  gateway's IP (i.e., Your lab machine). The ~iptables~ will then
  automatically change the replied packet's destination IP
  (~<ip-of-your-lab-machine>~) to the original source IP
  (~10.20.20.*~). This process is called a SNAT and you can implement
  it with ~iptables~ (see,
  https://www.systutorials.com/1372/setting-up-gateway-using-iptables-and-route-on-linux/).

  Set up the SNAT with ~iptables~. The following rule should be read
  "In the ~nat~ table, for packets that leave the machine (~-A
  POSTROUTING~) and incoming from network ~10.20.20.0/24~ (~-s~) and
  not at destination of the network ~10.20.20.0/24~ (~! -d~), then
  replace the sender's address by the gateway's address (~-j
  MASQUERADE~)."
  # : sudo iptables -t nat -A POSTROUTING ! -d 10.20.20.0/24 -o <NIC-of-your-lab-machine> -j SNAT --to-source <ip-of-your-lab-machine>
  : sudo iptables -t nat -A POSTROUTING -s 10.20.20.0/24 ! -d 10.20.20.0/24 -j MASQUERADE
  #+END_solution

#+END_do

#+BEGIN_note
If you are not familiar with the debugging of network issues but
interested in learning more I recommend to read blog post of support
teams.  Here are two that really are worth reading:
- https://cloud.google.com/blog/topics/inside-google-cloud/google-cloud-support-engineer-solves-a-tough-dns-case
- https://www.linkedin.com/pulse/name-resolution-issue-coredns-inside-mind-problem-solver-spitzer/
#+END_note

** In encryption we trust
:PROPERTIES:
:CUSTOM_ID: sec:enc-trust
:END:
Any cirros VMs share the same credentials (i.e., ~cirros~, ~gocubsgo~)
which is a security problem.  As a IaaS DevOps, you want that only
some clients can SSH on the VMs.  Fortunately, OpenStack helps with
the management of SSH keys.  OpenStack can generate a SSH key and push
the public counterpart on the VM.  Therefore, doing a ~ssh~ on the VM
will use the SSH key instead of asking the client to fill the
credentials.

Make an SSH key and store the private counterpart in =./admin.pem=.
Then, give that file the correct permission access.
: openstack keypair create --private-key ./admin.pem admin
: chmod 600 ./admin.pem

Start a new VM and ask OpenStack to copy the public counterpart of
your SSH key in the =~/.ssh/authorized_keys= of the VM (i.e., note the
~--key-name admin~).
#+BEGIN_SRC bash
openstack server create --wait --image cirros \
  --flavor m1.tiny --network test \
  --key-name admin cli-vm-adminkey
#+END_SRC

Attach it a floating IP.
#+BEGIN_SRC bash
openstack server add floating ip \
  cli-vm-adminkey \
  $(openstack floating ip create -c floating_ip_address -f value external)
#+END_SRC

Now you can access your VM using SSH without filling credentials.
#+BEGIN_SRC bash
openstack server ssh cli-vm-adminkey \
  --login cirros \
  --identity ./admin.pem
#+END_SRC

#+BEGIN_note
Or directly with the ~ssh~ command --- for bash lovers ❤.
: ssh -i ./admin.pem -l cirros $(openstack server show cli-vm-adminkey -c addresses -f value | sed  -Er 's/test=.+ (10\.20\.20\.[0-9]+).*/\1/g')

A regular ~ssh~ command looks like ~ssh -i <identity-file> -l <name>
<server-ip>~. The OpenStack command followed by the ~sed~ returns the
floating IP of ~cli-vm-adminkey~. You may have to adapt it a bit
according to your network cidr.
: openstack server show cli-vm-adminkey -c addresses -f value | sed  -Er 's/test=.+ (10\.20\.20\.[0-9]+).*/\1/g'
#+END_note

* Footnotes
[fn:g5k-tunnel] For sure, you always can setup an SSH tunnel but this
is a bit annoying.

* Variables                                                        :noexport:
#+STARTUP: entitiespretty
#+LANGUAGE: en
#+OPTIONS: ^:{} ':t email:t toc:nil
#+PROPERTY: header-args :mkdirp yes
#+LINK: cdn-url      https://github.com/BeyondTheClouds/lectures/blob/869b8f3/%s?raw=true
#+LINK: horizon-url  http://10.24.61.255

#+EXCLUDE_TAGS: noexport

# -- HTML specific options
#+OPTIONS: html-link-use-abs-url:nil html-preamble:t html-scripts:t html-style:t html5-fancy:t tex:t
#+HTML_DOCTYPE: html5
#+HTML_CONTAINER: div
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../../assets/css/org.css" />
#+HTML_HEAD: <style>#table-of-contents .tag {display: none;}</style>

# -- Programmed options
# Local Variables:
# org-html-postamble: "<p class=\"author\">Author: %a</p>
# <p class=\"email\">Email: %e</p>
# <p class=\"github\">Find a typo, wanna make a proposition:
#  <a href=\"https://github.com/BeyondTheClouds/lectures/issues/new?title=[os-imt]\">open an issue</a></p>
# <p class=\"date\">Last modification: %C</p>
# <p class=\"license\">This work is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
# <p class=\"creator\">%c – <a href=\"http://gongzhitaao.org/orgcss\">Zhitao Gong</a> customized theme</p>"
# eval: (progn
# (defun os-doc (tag)
#           (let* ((split-tag (s-split "," tag))
#                  (os-service (or (-first-item split-tag)
#                                  (error "OpenStack service name is required in %s" tag)))
#                  (os-url     (or (-second-item split-tag) "")))
#             (s-lex-format "https://docs.openstack.org/${os-service}/ussuri/${os-url}")))
# (add-to-list 'org-link-abbrev-alist '("os-doc" . "%(os-doc)"))
# )
# End:
